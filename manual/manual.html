<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="manual.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  March 19, 2004 MathHTML (c) Peter Jipsen http://www.chapman.edu/~jipsen
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  
  function convertMath(node) {// for Gecko
    if (node.nodeType==1) {
      var newnode =
        document.createElementNS("http://www.w3.org/1998/Math/MathML",
          node.nodeName.toLowerCase());
      for(var i=0; i < node.attributes.length; i++)
        newnode.setAttribute(node.attributes[i].nodeName,
          node.attributes[i].value);
      for (var i=0; i<node.childNodes.length; i++) {
        var st = node.childNodes[i].nodeValue;
        if (st==null || st.slice(0,1)!=" " && st.slice(0,1)!="\n")
          newnode.appendChild(convertMath(node.childNodes[i]));
      }
      return newnode;
    }
    else return node;
  }
  
  function convert() {
    var mmlnode = document.getElementsByTagName("math");
    var st,str,node,newnode;
    for (var i=0; i<mmlnode.length; i++)
      if (document.createElementNS!=null)
        mmlnode[i].parentNode.replaceChild(convertMath(mmlnode[i]),mmlnode[i]);
      else { // convert for IE
        str = "";
        node = mmlnode[i];
        while (node.nodeName!="/MATH") {
          st = node.nodeName.toLowerCase();
          if (st=="#text") str += node.nodeValue;
          else {
            str += (st.slice(0,1)=="/" ? "</m:"+st.slice(1) : "<m:"+st);
            if (st.slice(0,1)!="/")
               for(var j=0; j < node.attributes.length; j++)
                 if (node.attributes[j].value!="italic" &&
                   node.attributes[j].value!="" &&
                   node.attributes[j].value!="inherit" &&
                   node.attributes[j].value!=undefined)
                   str += " "+node.attributes[j].nodeName+"="+
                       "\""+node.attributes[j].value+"\"";
            str += ">";
          }
          node = node.nextSibling;
          node.parentNode.removeChild(node.previousSibling);
        }
        str += "</m:math>";
        newnode = document.createElement("span");
        node.parentNode.replaceChild(newnode,node);
        newnode.innerHTML = str;
      }
  }
  
  if (document.createElementNS==null) {
    document.write("<object id=\"mathplayer\"\
    classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
    document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
  }
  if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('load', convert, false);
  }
  if(typeof window.attachEvent != 'undefined') {
    window.attachEvent('onload', convert);
  }
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<h2 id="toctitle">Table of contents</h2>
<ul class="incremental">
<li><a href="#dependencies-of-the-scripts">Dependencies of the scripts</a><ul class="incremental">
<li><a href="#install-packages-for-r">Install packages for R</a></li>
<li><a href="#install-packages-for-python">Install packages for Python</a></li>
</ul></li>
<li><a href="#genome-preparation">Genome Preparation</a><ul class="incremental">
<li><a href="#record-index-table">Record index table</a></li>
</ul></li>
<li><a href="#generating-sample-reads">Generating sample reads</a><ul class="incremental">
<li><a href="#generate-nucleotide-strings-and-read-names">Generate nucleotide strings and read names</a></li>
<li><a href="#putting-together-the-fastq-file">Putting together the FASTQ file</a></li>
<li><a href="#read-names">Read names</a></li>
<li><a href="#quality-strings">Quality strings</a></li>
<li><a href="#putting-the-fastq-file-together">Putting the FASTQ file together</a></li>
<li><a href="#repeat-the-above-steps-to-generate-contaminant-reads">Repeat the above steps to generate contaminant reads</a></li>
</ul></li>
<li><a href="#mutation-of-reads">Mutation of reads</a><ul class="incremental">
<li><a href="#mutation-probabilities">Mutation probabilities</a></li>
<li><a href="#specifying-the-parameters">Specifying the parameters</a></li>
<li><a href="#mutate-a-sequence">Mutate a sequence</a></li>
<li><a href="#combining-endogenous-and-non-endogenous-reads">Combining endogenous and non-endogenous reads</a></li>
<li><a href="#obtaining-mutation-rates-from-mapdamage">Obtaining mutation rates from mapDamage</a></li>
<li><a href="#generating-multiple-damage-patterns-using-a-parameter-table">Generating multiple damage patterns using a parameter table</a></li>
</ul></li>
<li><a href="#generate-mapper-calls">Generate mapper calls</a></li>
<li><a href="#executing-multiple-mapping-runs-in-parallel">Executing multiple mapping runs in parallel</a></li>
<li><a href="#parsing-of-sam-files">Parsing of SAM files</a><ul class="incremental">
<li><a href="#extraction-of-information">Extraction of information</a></li>
<li><a href="#gather-all-information-needed-to-determine-correct-mapping">Gather all information needed to determine correct mapping</a></li>
<li><a href="#grouping-of-reads">Grouping of reads</a></li>
<li><a href="#sensitivity-and-specificity">Sensitivity and specificity</a></li>
<li><a href="#repeat-all-steps-for-every-sam-file">Repeat all steps for every SAM file</a></li>
</ul></li>
<li><a href="#comparing-multiple-mapper-runs">Comparing multiple mapper runs</a></li>
<li><a href="#overview-of-the-scripts-by-category">Overview of the scripts by category</a><ul class="incremental">
<li><a href="#general-file-and-table-manipulation">General file and table manipulation</a></li>
<li><a href="#read-sampling-and-fitering">Read sampling and fitering</a></li>
<li><a href="#introducing-mutations-into-reads">Introducing mutations into reads</a></li>
<li><a href="#parallel-program-calls-e.g.-mappers">Parallel program calls (e.g. mappers)</a></li>
<li><a href="#sam-parsing-and-result-data-handling">SAM parsing and result data handling</a></li>
</ul></li>
<li><a href="#glossary">Glossary</a></li>
</ul>
</div>
<p><span class="title">The TAPAS manual</span></p>
<h1 id="dependencies-of-the-scripts">Dependencies of the scripts</h1>
<p>The scripts consisting this software depend on</p>
<ul class="incremental">
<li>A Python 3 installation</li>
<li>R</li>
</ul>
<p>Furthermore, the scripts depend on several packages for R and Python.</p>
<p>To check whether all dependencies are met, execute the following command. It is included in the <code>scripts/</code> folder.</p>
<pre><code>scripts/setup_check_dependencies</code></pre>
<p>Check the output of this script to find package names which are not installed or can't be loaded because of eventual errors.</p>
<p>Then install these packages manually by using</p>
<h2 id="install-packages-for-r">Install packages for R</h2>
<p>Install missing packages in R by executing the following command inside the R command prompt (type <code>R</code> into your shell to invoke it)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;PACKAGENAME&quot;</span>)</code></pre></div>
<h2 id="install-packages-for-python">Install packages for Python</h2>
<p>Invoke the Python package manager <code>pip3</code> to install packages for Python:</p>
<pre><code>pip3 install PACKAGENAME...</code></pre>
<p>You may specify multiple package names by writing them one after another, separated by whitespace.</p>
<h1 id="genome-preparation">Genome Preparation</h1>
<h2 id="record-index-table">Record index table</h2>
<p>First, index the genome using <code>samtools</code>. This is needed for several downstream tools:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">samtools</span> faidx data/genome/volpertinger.fasta</code></pre></div>
<pre class="output"><code></code></pre>
<h1 id="generating-sample-reads">Generating sample reads</h1>
<p>The output FASTQ file will be constructed by interleaving the contents of three files, containing the read names, the nucleotide strings and the quality strings, respectively. These files will be generated in the following.</p>
<p>Additionally, a table containing the read names with the true read positions will be created, to evaluate later on whether a read was mapped correctly.</p>
<h2 id="generate-nucleotide-strings-and-read-names">Generate nucleotide strings and read names</h2>
<p>The <code>uniform</code> script can be used to sample reads from a reference genome. The script needs a FASTA file as input, as well as the desired amount of reads to be generated, the minimum length and the decay length. The read lengths are exponentially distributed; the decay length parameter specifies the length by which half of the reads are longer than the minimum read length.</p>
<p>For the FASTA file, an index file must exist which was generated in the previous section using samtools.</p>
<p>Example: Extract 25 reads, with minimum length 20 basepairs, where half of the reads have a length longer than 25 bp. The value 123 is used to initialize the random number generator, i.e. can be used to obtain reproducible reads. This last parameter can be omitted.</p>
<p>The resulting output will be a raw list of nucleotide sequences and a table containing three columns:</p>
<ol class="incremental" style="list-style-type: decimal">
<li>The FASTA record name (e.g. chromosome) where the read originated.</li>
<li>1-based base number of the reads' first base.</li>
<li>1-based base number of the reads' last base.</li>
</ol>
<p>The base indices are 1-based because base indices are 1-based in SAM-files as well. (whereas in BAM-files, they are 0-based, but we don't need to deal with BAM-files here.)</p>
<p>We will generate sample reads from our sample genome of a volpertinger.</p>
<p>Execute the following script to generate random nucleotide sequences:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/uniform</span> data/genome/volpertinger.fasta \
    --seed 1234 \
    --output data/2/volpertinger.coord data/2/volpertinger.nucl \
    25 20 5</code></pre></div>
<pre class="output"><code></code></pre>
<p>Two files are generated when the <code>--output</code> switch is used, as is the case above: One holds the read names and coordinates and the other one holds the raw nucleotide sequences. When omitting <code>--output</code>, all information is printed in tabular form on the standard output and not saved to distinct files.</p>
<p>The resulting files look like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">head</span> data/2/volpertinger.coord <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>record  start  end
B1      2143   2168
MT      3402   3421
A3      1413   1436
A3      5689   5709
MT      3280   3302
A3      4936   4960
A1      1320   1340
A3      4480   4504
X       2381   2400</code></pre>
<h2 id="putting-together-the-fastq-file">Putting together the FASTQ file</h2>
<p>This task needs three input files:</p>
<ol class="incremental" style="list-style-type: decimal">
<li>The list of read names</li>
<li>The list of nucleotide strings</li>
<li>The list of quality strings</li>
</ol>
<p>The first list is extracted from the file <code>volpertinger.coord</code>, the second list exists already (<code>volpertinger.nucl</code>) and the third list is generated using standard UNIX tools from the nucleotide strings</p>
<h2 id="read-names">Read names</h2>
<p>In this tutorial we generate read names consisting of the organism name (<em>volpertinger</em>) followed by an underscore and a counting number.</p>
<p>To have the origin information of the reads available along with their newly-generated reads, it is advisable to add the read names to the <code>volpertinger.coord</code> file generated above.</p>
<p>There is a script included for adding this kind of column, which is shown in the next code example. You can as well use <code>awk</code> or whichever tool you like to accomplish this task if you need more sophisticated read names.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/index_column</span>  --prefix volpertinger_ \
                      --colname name  \
                      --inplace data/2/volpertinger.coord

<span class="kw">head</span> data/2/volpertinger.coord <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>name            record  start  end
volpertinger_0  B1      2143   2168
volpertinger_1  MT      3402   3421
volpertinger_2  A3      1413   1436
volpertinger_3  A3      5689   5709
volpertinger_4  MT      3280   3302
volpertinger_5  A3      4936   4960
volpertinger_6  A1      1320   1340
volpertinger_7  A3      4480   4504
volpertinger_8  X       2381   2400</code></pre>
<p>To use the read names to generate a FASTQ file, they must be available as a raw list without additional columns or a header. <code>awk</code> can be used to perform this task:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">awk</span> <span class="st">&#39;(NR!=1){print $1}&#39;</span> \
      data/2/volpertinger.coord \
    <span class="kw">&gt;</span> data/2/volpertinger.i

<span class="kw">head</span> data/2/volpertinger.i</code></pre></div>
<pre class="output"><code>volpertinger_0
volpertinger_1
volpertinger_2
volpertinger_3
volpertinger_4
volpertinger_5
volpertinger_6
volpertinger_7
volpertinger_8
volpertinger_9</code></pre>
<h2 id="quality-strings">Quality strings</h2>
<p>Currently, the effect of quality strings on the mapping result has not been investigated. Currently only strings of constant quality score are used. This can be done by the UNIX <code>sed</code> tool, which replaces every character by an F:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sed</span> <span class="st">&#39;s/./F/g&#39;</span> \
      data/2/volpertinger.nucl \
    <span class="kw">&gt;</span> data/2/volpertinger.q

<span class="kw">head</span> data/2/volpertinger.q</code></pre></div>
<pre class="output"><code>FFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></pre>
<p>If you want to generate more elaborate quality strings, you are free to do so using whichever tools you desire. Just generate a list with as many lines as there are nucleotide strings in <code>volpertinger.nucl</code> to input them into the pipeline.</p>
<h2 id="putting-the-fastq-file-together">Putting the FASTQ file together</h2>
<p>The <code>synth_fastq</code> tool creates a FASTQ file from its components, nucleotide string, quality string and read name (ID line). If the file containing the read lines is omitted, the reads are numbered sequentially.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/synth_fastq</span> data/2/volpertinger.nucl \
                    data/2/volpertinger.q    \
                    data/2/volpertinger.i    \
    <span class="kw">&gt;</span> data/2/volpertinger.fastq

<span class="kw">head</span> data/2/volpertinger.fastq</code></pre></div>
<pre class="output"><code>@volpertinger_0
TTCCACAAGATATTAGCCAACCAGAT
+
FFFFFFFFFFFFFFFFFFFFFFFFFF
@volpertinger_1
TCTATTTAATAACTTCTCCC
+
FFFFFFFFFFFFFFFFFFFF
@volpertinger_2
TTGAACTCTATCTTCCGGGGCTCA</code></pre>
<h2 id="repeat-the-above-steps-to-generate-contaminant-reads">Repeat the above steps to generate contaminant reads</h2>
<p>This commands generate some reads from a truncated <em>Rhizobium etli</em> genome, to supply reads which are not supposed to map. This way, contamination with non-endogenous reads are simulated.</p>
<p>The endogenous (<code>volpertinger.fastq</code>) and contaminant (<code>retli.fastq</code>) read will be merged into one fastq file (<code>all.fastq</code>) once the sample reads have undergone mutation simulation. This will be done in the next section.</p>
<p>Note that two kinds of abbreviations are used here:</p>
<ul class="incremental">
<li>Terms like <code>const_{a,b,c}</code> are expanded by <code>bash</code> to <code>const_a const_b const_c</code> and can therefore be used to specify mulitple paths which share some parts.</li>
<li>The temporary files (similar to <code>volpertinger.q</code> and <code>volpertinger.i</code> above) are omitted here by using <code>bash</code>'s <em>process substitution</em> (<code>&lt;(...)</code>) which uses the output of one argument instead of a file name which the other command expects.</li>
</ul>
<p>If you do not understand why these commands are equivalent to the commands listed above used to generate <code>reads.fastq</code>, you can use these as well without problems.</p>
<p>Index genome and sample nucleotide seqences:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">samtools</span> faidx data/retli/retli_tr.fasta

<span class="kw">scripts/uniform</span> \
    data/retli/retli_tr.fasta \
    --seed 2345 \
    --output data/2/retli.<span class="dt">{coord,nucl}</span> \
    25 20 5</code></pre></div>
<pre class="output"><code></code></pre>
<p>Read names:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/index_column</span>  --prefix retli_ \
                      --colname name  \
                      --inplace data/2/retli.coord</code></pre></div>
<pre class="output"><code></code></pre>
<p>Put the FASTQ together:</p>
<ul class="incremental">
<li>Quality strings are generated without an intermediate file using <code>sed</code></li>
<li>Read names are extracted without an intermediate file using <code>awk</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/synth_fastq</span> \
    data/2/retli.nucl \
    <span class="kw">&lt;(sed</span> <span class="st">&#39;s/./F/g&#39;</span>           data/2/retli.nucl<span class="kw">)</span> \
    <span class="kw">&lt;(awk</span> <span class="st">&#39;(NR!=1){print $1}&#39;</span> data/2/retli.coord<span class="kw">)</span> \
    <span class="kw">&gt;</span> data/2/retli.fastq

<span class="kw">head</span> data/2/retli.fastq</code></pre></div>
<pre class="output"><code>@retli_0
TCGTTCTTGTAGCCTTCCGGGAA
+
FFFFFFFFFFFFFFFFFFFFFFF
@retli_1
ACTGAAGCGCAAGCTCTGAA
+
FFFFFFFFFFFFFFFFFFFF
@retli_2
TGGCCGAGGGACGCTTGCGTCG</code></pre>
<h1 id="mutation-of-reads">Mutation of reads</h1>
<h2 id="mutation-probabilities">Mutation probabilities</h2>
<p>The reads are mutated using per base probabilities derived from the geometric distribution. The mutation probability at the read ends is the highest. By this, the chemical damage near read ends can be modelled. For this, three parameters are important:</p>
<ul class="incremental">
<li><p>The base-independent mutation probability <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>t</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;t&lt;1</annotation></semantics></math>). This is the probability of any base to mutate, regardless of its proximity to the end of the read. This can be used to model evolutionary distance.</p></li>
<li><p>The steepness <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;p&lt;1</annotation></semantics></math>) of the mutation probability decline when moving away from the read end. The higher this parameter the steeper is the decline of mutation probability when moving away from the read end.</p></li>
<li><p>The multiplying factor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>. At the read end, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">f+t</annotation></semantics></math> is the probability of the first base of the read to be mutated.</p></li>
</ul>
<p>With this model, its possible to archive mutation probabilities greater than one. This makes of course no sense and the mutation probability is cut back to one in such cases.</p>
<p>In mathematical notation, the mutation probability <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>m</mi><mi>u</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">P_{mut}</annotation></semantics></math> of a base number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, starting to count at the reads' end, is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>m</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo>⋅</mo><mi>d</mi><mi>g</mi><mi>e</mi><mi>o</mi><mi>m</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>;</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">P_{mut}(x) = f \cdot dgeom(x;p) + t</annotation></semantics></math></p>
<p>with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>g</mi><mi>e</mi><mi>o</mi><mi>m</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>;</mo><mi>P</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">dgeom(X;P)</annotation></semantics></math> being the density function of the geometric distribution, with parameters X = number of tries; P = success probability.</p>
<p>The following sketch graphs illustrate the three parameters:</p>
<p><img src="fig/mut.svg" width="800" /></p>
<h2 id="specifying-the-parameters">Specifying the parameters</h2>
<p>The mutation probabilities are saved as a text table. It looks like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cat</span> data/mut-tables/mut.tab</code></pre></div>
<pre class="output"><code>strand   from   to   factor  geom_prob  intercept
3        C      T    0.3     0.4        0.1
5        C      T    0.1     0.2        0.0
3        *      *    0.0     0.1        0.12</code></pre>
<p>The columns have the following meaning:</p>
<ul class="incremental">
<li>strand: [3 or 5] On which end of the read should base 1 be located, the base with the highest mutation probability</li>
<li>from: [Letter or *] Which bases should mutate according to this lines' parameters. * means this rule applies to every base.</li>
<li>to: [Letter or *] Which base should a mutation event yield. * means a base (A,T,C,G) different from the original base is chosen at random.</li>
<li>factor: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> from the previous section</li>
<li>geom_prob: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> from the previous section</li>
<li>intercept: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> from the previous section</li>
</ul>
<p>In the example above, a base is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> bp away from the 5' end of a read of length l. That means, it is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mo>−</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(l-x)</annotation></semantics></math> bp away from the 3' end of the read. The exchange probability depends on the type of the nucleotide and on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>:</p>
<p>Base at position <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not Cytosine:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mo>*</mo><mo accent="false">→</mo><mo>*</mo></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn><mo>×</mo><mi>d</mi><mi>g</mi><mi>e</mi><mi>o</mi><mi>m</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>;</mo><mn>0.1</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mn>0.12</mn><mo>=</mo><mn>0.12</mn><mo>=</mo><msub><mi>P</mi><mrow><mo>*</mo><mo accent="false">→</mo><mo>*</mo></mrow></msub></mrow><annotation encoding="application/x-tex">P_{\ast\rightarrow\ast}(x) = 0 \times dgeom(x;0.1) + 0.12 = 0.12 = 
P_{\ast\rightarrow\ast}</annotation></semantics></math></p>
<p>Base at position <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is Cytosine (C):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>C</mi><mo accent="false">→</mo><mi>T</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>P</mi><mrow><mo>*</mo><mo accent="false">→</mo><mo>*</mo></mrow></msub><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mn>0.3</mn><mo>×</mo><mi>d</mi><mi>g</mi><mi>e</mi><mi>o</mi><mi>m</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>;</mo><mn>0.4</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mn>0.1</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mn>0.1</mn><mo>×</mo><mi>d</mi><mi>g</mi><mi>e</mi><mi>o</mi><mi>m</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mo>−</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>;</mo><mn>0.2</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mn>0.0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P_{C\rightarrow T}(x) = P_{\ast\rightarrow\ast} + 
          (0.3\times dgeom(x;0.4) + 0.1) + 
          (0.1\times dgeom((l-x);0.2) + 0.0) </annotation></semantics></math></p>
<h2 id="mutate-a-sequence">Mutate a sequence</h2>
<p>The <code>multiple-mutate.py</code> tool takes a table of the previous section as input and mutates strings provided to it on standard input accordingly.</p>
<p>Mutations can be inserted either before a FASTQ file is assembled (<code>synth_fastq.py</code>, see previous section), or afterwards. This example uses raw nucleotide strings generate during the creation of our <em>volpertinger</em> samples. This serves well as an example how nucleotide strings are processed line by line and mutated. You can see the mutations in this example showing up as lower-case letters.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts</span>/<span class="kw">multiple_mutate</span>\
    data/mut-tables/mut.tab \
    <span class="kw">&lt;</span> data/2/volpertinger.nucl \
    <span class="kw">|</span> <span class="kw">head</span></code></pre></div>
<pre class="output"><code>TTCgACAAGcTATTAGCTAACCAGcT
aCTATTTcATgtCTTTTCCC
TTGAgCTCTtTCTTCCGGGGCTCA
TCATGAGGGTTTtTAcTTctA
TATGAaCcCGtTGTTGGATCAGG
ACCgAAGGGCCCCCAGCTAGGTTGt
TcGGAATAGCCCTGTGTTTAT
tATAAACTTAgAtcAATTAaTGGCA
ACGtcGAgCATTTTCTTGTG
TATGGTATgTGGTATATATGTAGgTgGTGTG</code></pre>
<p>An already existent FASTQ file can be mutated using the <code>filter_fastq</code> tool in cooperation with <code>multiple-mutate</code>. The tool <code>filter_fastq</code> enables you to apply transformations to existing fastq files. To this effect, <code>filter_fastq</code> extracts one part out of a FASTQ file (read name, nucleotide string or quality string) and feeds it into another sub-program specified between two <code>@</code>-signs. The sub-program is required to take lines of text as input and return the same number of lines on standard output. The output of the sub-program is then placed into the output fastq file. By combining <code>filter_fastq</code> and <code>multiple_mutate</code>, the tool which applies mutations to strings of nucleotides, a FASTQ file can be mutated:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/filter_fastq</span> --nucleotide \
  @ scripts/multiple_mutate data/mut-tables/mut.tab @ \
  <span class="kw">&lt;</span> data/2/volpertinger.fastq \
  <span class="kw">&gt;</span> data/3/volpertinger_mut.fastq</code></pre></div>
<pre class="output"><code></code></pre>
<p>Note how the nucleotide strings of the output FASTQ file now carry mutations (lower-case letters):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">head</span> data/3/volpertinger_mut.fastq</code></pre></div>
<pre class="output"><code>@volpertinger_0
TTCaACAAGATATTAGCTtcCaAGAT
+
FFFFFFFFFFFFFFFFFFFFFFFFFF
@volpertinger_1
cCTATTTAggAACTTCTCCc
+
FFFFFFFFFFFFFFFFFFFF
@volpertinger_2
TTGAACTCTATCTTTCcGGGCTCA</code></pre>
<p>The <code>filter_fastq.py</code> script enables you to apply an arbitrary script or program on just one part of a FASTQ file (ID line, nucleotide line, quality line). The used script must accept the respective part on standard input and print the modified version on standard output. The modified FASTQ file is assembled by <code>filter_fastq.py</code> from the output of its children scripts and printed on standard output.</p>
<p>On the <code>filter_fastq.py</code> call, the @ sign serves as a sentinel character, which determines start and end of the sub-program's command line. It can also be any arbitrary other character, as long as it doesn't occur inside the child script's command line but only at the beginning and the end.</p>
<h2 id="combining-endogenous-and-non-endogenous-reads">Combining endogenous and non-endogenous reads</h2>
<p>In this example, the endogenous reads from <em>volptertinger</em> undergo simulated mutation and damage prior to mapping, while the contaminant reads from <em>R. etli</em> do not.</p>
<p>Therefore only now, after applying mutations to our <em>volpertinger</em> reads, is the time to combine the mutated sample reads and the contaminant reads generated in the last section to one file. For this purpose, the UNIX tool <code>cat</code> is used:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cat</span> data/3/volpertinger_mut.fastq data/2/retli.fastq \
    <span class="kw">&gt;</span> data/3/all.fastq</code></pre></div>
<pre class="output"><code></code></pre>
<h2 id="obtaining-mutation-rates-from-mapdamage">Obtaining mutation rates from mapDamage</h2>
<p>Damage patterns from mapDamage can be converted into a table with mutation parameters by least-squares fitting. For this purpose, the mapDamage output files ending with <code>... _freq.txt</code> are needed.</p>
<p>The following command fits a geometric distribution to mapDamage data, shows the derived parameters and plots the data with the fitted curve.</p>
<p>The <code>cut</code> command is used only to limit the output to a width acceptable for this manual. Use the bash <code>&gt;</code> redirection operator to write this output into a file suitable for <code>multiple_mutate.py</code>.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/mapdamage2geomparam</span> \
    --fit-plots data/3/fit_ \
    data/mapdamage/*.txt <span class="kw">|</span> <span class="kw">\</span>
    <span class="kw">cut</span> -f1-6 <span class="kw">|</span> <span class="kw">\</span>
    <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>strand  fromBase  toBase  factor          geom_prob       intercept
3       G         A       0.795141407627  0.269186574395  0.0393868749241
5       C         T       0.433601194732  0.352493013329  0.0279655759856</code></pre>
<p>The generated plots can be viewed <a href="data/3/fit_001_GS136_5pCtoT_freq.txt.pdf">here (C→T)</a> and <a href="data/3/fit_000_GS136_3pGtoA_freq.txt.pdf">here (G→A)</a>. fit_000_GS136_3pGtoA_freq.txt.pdf</p>
<h2 id="generating-multiple-damage-patterns-using-a-parameter-table">Generating multiple damage patterns using a parameter table</h2>
<p>Sometimes, multiple damage patterns need to be compared. There is a possibility to generate the <code>multiple_mutate</code> input files from one table which lists all different values of the different mutation parameters.</p>
<p>This approach will be seen again later, where there is a possibility to generate many short read mapper calls from exactly the same kind of parameter table. You can therefore generate appropriate input files as well as appropriate short read mapper calls out of only one table which lists all the parameters.</p>
<p>The <code>fill_template.py</code> script expects a table, where each row is used to fill a prespecified template with values.</p>
<p>For example, if a template is written which looks like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cp</span> data/mut-tmpl/mut-tmpl data/3
<span class="kw">column</span> -t data/3/mut-tmpl</code></pre></div>
<pre class="output"><code>strand  from  to  factor  geom_prob  intercept
5       C     T   {fac}   {geom}     0
3       G     A   {fac}   {geom}     0
3       *     *   0       0          {all_intercept}</code></pre>
<p>And a table is created which looks like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cp</span> data/mut-tmpl/tab data/3/mut-tab
<span class="kw">column</span> -t data/3/mut-tab</code></pre></div>
<pre class="output"><code>fac  geom  all_intercept
0    0.1   0
0    0.1   0.3
0.5  0.1   0
0.5  0.1   0.3</code></pre>
<p>several files can be generated with</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/fill_template</span> \
    data/3/mut-tmpl \
    <span class="kw">&lt;</span> data/3/mut-tab</code></pre></div>
<pre class="output"><code>strand  from    to  factor  geom_prob   intercept
5   C   T   0   0.1 0
3   G   A   0   0.1 0
3   *   *   0   0   0

strand  from    to  factor  geom_prob   intercept
5   C   T   0   0.1 0
3   G   A   0   0.1 0
3   *   *   0   0   0.3

strand  from    to  factor  geom_prob   intercept
5   C   T   0.5 0.1 0
3   G   A   0.5 0.1 0
3   *   *   0   0   0

strand  from    to  factor  geom_prob   intercept
5   C   T   0.5 0.1 0
3   G   A   0.5 0.1 0
3   *   *   0   0   0.3
</code></pre>
<p>Use the <code>--output</code> switch of this script to write each file in a separate file. The argument of <code>--output</code> can (and should!) contain column names of the table, enclosed in braces {...}. This creates a separate filename per input row.</p>
<p>We will now write each of the tables shown above to its own file. We want to name the files using a counting number, but our input table doesn't yet contain a column with that counter. Therefore we must first add one.</p>
<p>The mentioned-above table can be prepended with an index column:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/index_column</span> --inplace data/3/mut-tab

<span class="kw">head</span> data/3/mut-tab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>index  fac  geom  all_intercept
0      0    0.1   0
1      0    0.1   0.3
2      0.5  0.1   0
3      0.5  0.1   0.3</code></pre>
<p>Now, each output of <code>fill_template.py</code> can be written to its own output file, using the information from the newly-generated <code>index</code> column:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/fill_template</span> \
    --output <span class="st">&quot;data/3/{index}_filled&quot;</span> \
    data/3/mut-tmpl \
    <span class="kw">&lt;</span> data/3/mut-tab

<span class="co"># Show all the generated files</span>
<span class="kw">for</span> <span class="kw">f</span> in data/3/*_filled<span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">echo</span> <span class="st">&quot; === </span><span class="ot">$f</span><span class="st"> === &quot;</span>
    <span class="kw">column</span> -t <span class="ot">$f</span>
<span class="kw">done</span></code></pre></div>
<pre class="output"><code> === data/3/0_filled ===
strand  from  to  factor  geom_prob  intercept
5       C     T   0       0.1        0
3       G     A   0       0.1        0
3       *     *   0       0          0
 === data/3/1_filled ===
strand  from  to  factor  geom_prob  intercept
5       C     T   0       0.1        0
3       G     A   0       0.1        0
3       *     *   0       0          0.3
 === data/3/2_filled ===
strand  from  to  factor  geom_prob  intercept
5       C     T   0.5     0.1        0
3       G     A   0.5     0.1        0
3       *     *   0       0          0
 === data/3/3_filled ===
strand  from  to  factor  geom_prob  intercept
5       C     T   0.5     0.1        0
3       G     A   0.5     0.1        0
3       *     *   0       0          0.3</code></pre>
<p>If several combinations of mutation parameters shall be tested, <code>cross_tab.py</code> can be used to generate the table from predefined parameter values, like described with mapper parameters in the next section.</p>
<h1 id="generate-mapper-calls">Generate mapper calls</h1>
<p>To generate the calls to the mapper using different combinations of parameters, several files holding the values of the different parameters are first combined to a table holding all possible combinations of them.</p>
<p>Subsequently, every line is given a unique index which can be referred to e.g. when writing output files of the mapping process. By this index, each run writes to a different output file.</p>
<p>The parameter values are saved in several files, one per parameter. In this example, the BWA parameters n and k are varied which results in two files:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span> data/mapping/*.par</code></pre></div>
<pre class="output"><code>data/mapping/k.par
data/mapping/n.par</code></pre>
<p>The files can have arbitrary filenames, they are in a tabular format where the column names relate to variables which are set automatically later in the process.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">column</span> -t data/mapping/n.par</code></pre></div>
<pre class="output"><code>n
0
4
8</code></pre>
<p>To generate all combinations of parameters, two scripts are used:</p>
<ul class="incremental">
<li><p><code>scripts/cross_tab</code> expects multiple files and outputs all possible combinations of their lines.</p></li>
<li><p><code>scripts/index_column</code> This script prepends a counting number to each input line. It can be used to generate index columns for text tables.</p></li>
</ul>
<p>Generate all possible combinations of parameters, retaining 1 header line:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/cross_tab</span> --head 1 data/mapping/*.par <span class="kw">&gt;</span> data/4/partab
<span class="kw">head</span> data/4/partab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>k   n
2   0
2   4
2   8
10  0
10  4
10  8</code></pre>
<p>Add an index column called runidx:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/index_column</span> --colname runidx --inplace data/4/partab
<span class="kw">head</span> data/4/partab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>runidx  k   n
0       2   0
1       2   4
2       2   8
3       10  0
4       10  4
5       10  8</code></pre>
<p>Read now the script <code>data/mapping/map-bwa.sh</code> and see how the variables used there correspond to the column names of partab. The script is shown in the next code block.</p>
<p>This is a script which can be called using different parameter combinations: It calls the mapper <code>bwa</code> and forwards the values of the variables set via <code>data/4/partab</code> as command line arguments to the mapper.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/bash</span>

<span class="co">## This script performs a mapping using BWA.</span>
<span class="co">## It requires the variables k, n, runidx and fastq be set </span>
<span class="co">## prior to its execution.</span>

<span class="co"># Fail if any needed variable is not set</span>
<span class="kw">set</span> <span class="kw">-ue</span>

<span class="kw">bwa</span> aln -n <span class="ot">${n}</span> -k <span class="ot">${k}</span>      \
    data/genome/volpertinger \
    data/3/all.fastq         \
    <span class="kw">&gt;</span> data/4/<span class="ot">${runidx}</span>.sai   \
    <span class="kw">2&gt;</span> data/4/<span class="ot">${runidx}</span>.log   <span class="kw">&amp;&amp;</span>

<span class="kw">bwa</span> samse                      \
      data/genome/volpertinger \
      data/4/<span class="ot">${runidx}</span>.sai     \
      data/3/all.fastq         \
      <span class="kw">&gt;</span> data/4/<span class="ot">${runidx}</span>.sam   \
      <span class="kw">2&gt;&gt;</span> data/4/<span class="ot">${runidx}</span>.log</code></pre></div>
<p>Below the calls are generated.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Convert the table into calls that can be executed in the next section</span>
<span class="kw">scripts/table2calls</span>  data/4/partab \
                    data/mapping/map-bwa.sh \
                  <span class="kw">&gt;</span> data/4/calls
<span class="kw">cat</span> data/4/calls</code></pre></div>
<pre class="output"><code>k=2 runidx=0 n=0 data/mapping/map-bwa.sh
k=2 runidx=1 n=4 data/mapping/map-bwa.sh
k=2 runidx=2 n=8 data/mapping/map-bwa.sh
k=10 runidx=3 n=0 data/mapping/map-bwa.sh
k=10 runidx=4 n=4 data/mapping/map-bwa.sh
k=10 runidx=5 n=8 data/mapping/map-bwa.sh</code></pre>
<h1 id="executing-multiple-mapping-runs-in-parallel">Executing multiple mapping runs in parallel</h1>
<p>For this task, many programs can be used, from simple shell background spawning using &amp; (in bash) to job managers orchestrating a big network of worker machines. In this package, a simple program is implemented which executes a user-definable number of jobs in parallel and waits with spawning new ones until another of its already started jobs finishes.</p>
<p>Note that some mappers can use more than one processor core themselves. Therefore if you spawn multiple mapper processes where each mapper process utilizes multiple cores, the total number of utilized cores is the number of cores used per mapper multiplied with the number of mapper processes launched in parallel.</p>
<p>Invoke <code>scripts/mcall --help</code> to get more information about this tool.</p>
<p>Example: Run the previously generated mapper calls.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">    <span class="co"># Execute calls, at 2 cores</span>
    <span class="kw">scripts/mcall</span> -c data/4/calls -t 2 \
                  --status
    <span class="co"># Standard error was piped to log files,</span>
    <span class="co"># Standard output was piped to sam files, as specified in the</span>
    <span class="co"># `tmpl` file.</span>
    <span class="kw">head</span> data/4/0.log
    <span class="kw">head</span> -n15 data/4/0.sam</code></pre></div>
<pre class="output"><code>[bwa_aln_core] calculate SA coordinate... 0.00 sec
[bwa_aln_core] write to the disk... 0.00 sec
[bwa_aln_core] 50 sequences have been processed.
[main] Version: 0.7.13-r1126
[main] CMD: bwa aln -n 0 -k 2 data/genome/volpertinger data/3/all.fastq
[main] Real time: 0.074 sec; CPU: 0.003 sec
[bwa_aln_core] convert to sequence coordinate... 0.00 sec
[bwa_aln_core] refine gapped alignments... 0.00 sec
[bwa_aln_core] print alignments... 0.00 sec
[bwa_aln_core] 50 sequences have been processed.
@SQ SN:A1   LN:6000
@SQ SN:A2   LN:6000
@SQ SN:A3   LN:6000
@SQ SN:B1   LN:6000
@SQ SN:B2   LN:6000
@SQ SN:B3   LN:6000
@SQ SN:B4   LN:6000
@SQ SN:MT   LN:6000
@SQ SN:X    LN:6000
@PG ID:bwa  PN:bwa  VN:0.7.13-r1126 CL:bwa samse data/genome/volpertinger data/4/0.sai data/3/all.fastq
volpertinger_0  4   *   0   0   *   *   0   0   TTCAACAAGATATTAGCTTCCAAGAT  FFFFFFFFFFFFFFFFFFFFFFFFFF
volpertinger_1  4   *   0   0   *   *   0   0   CCTATTTAGGAACTTCTCCC    FFFFFFFFFFFFFFFFFFFF
volpertinger_2  4   *   0   0   *   *   0   0   TTGAACTCTATCTTTCCGGGCTCA    FFFFFFFFFFFFFFFFFFFFFFFF
volpertinger_3  4   *   0   0   *   *   0   0   TCATATGGGTATCTATTTTGA   FFFFFFFFFFFFFFFFFFFFF
volpertinger_4  4   *   0   0   *   *   0   0   TATGTCTTCGAAGTTGGATTTGG FFFFFFFFFFFFFFFFFFFFFFF</code></pre>
<h1 id="parsing-of-sam-files">Parsing of SAM files</h1>
<p>With the following tools, SAM files can be parsed to gain information of read names, where they were mapped, which quality score the mapping was assigned and so on.</p>
<p>The procedures in this chapter may vary more than the previous ones, depending on the research question.</p>
<p>In the setting this package was originally designed for, the names of the reads carry the information where the reads actually belong to. This information can subsequently be compared to the actual mapping information obtained from the SAM file.</p>
<h2 id="extraction-of-information">Extraction of information</h2>
<p>For this purpose, the <code>sam-extract.R</code> tool can be used. This tool converts a SAM file into a table, where the columns can be informations obtained from the read names or SAM fields. The names of the SAM fields can be looked up in the SAM specification online, but the most important ones are:</p>
<ul class="incremental">
<li>qname: read name</li>
<li>rname: FASTA record name of genome this read was mapped to. <code>*</code> if not mapped.</li>
<li>pos: base index of mapping position (1-based index!)</li>
<li>mapq: quality score assigned by the mapper</li>
<li>cigar: CIGAR String: Information about gaps and mismatches in the alignment read -- reference</li>
</ul>
<p>Take care not to put any spaces in the argument of --sam-fields.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/sam_extract</span> --sam-fields qname,rname,pos,mapq \
    data/4/1.sam  <span class="kw">&gt;</span>  data/5/1.tab</code></pre></div>
<pre class="output"><code></code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">head</span> data/5/1.tab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>qname           rname  pos   mapq
volpertinger_0  *      0     0
volpertinger_1  MT     3402  37
volpertinger_2  A3     1413  37
volpertinger_3  A3     5689  25
volpertinger_4  *      0     0
volpertinger_5  *      0     0
volpertinger_6  A1     1320  37
volpertinger_7  A3     4480  25
volpertinger_8  X      2381  37</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">tail</span> data/5/1.tab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>retli_15  *   0     0
retli_16  MT  2791  25
retli_17  *   0     0
retli_18  *   0     0
retli_19  *   0     0
retli_20  *   0     0
retli_21  *   0     0
retli_22  *   0     0
retli_23  *   0     0
retli_24  *   0     0</code></pre>
<h2 id="gather-all-information-needed-to-determine-correct-mapping">Gather all information needed to determine correct mapping</h2>
<p>The script <code>add_mapped_organisms</code> adds two columns to the result above: The column <code>true_organism</code> lists the organism a read stems from. This is an important information if the FASTA record names of several species used in the analysis overlap. This is sometimes the case when multiple eukaryotes are used. The second column, <code>mapped_organism</code>, infers the organism a read has been assigned to by the mapper. This is done by looking up the FASTA record name, which the read was mapped to, in all FASTA record names of all species which where used as reference genomes by the mapper. This FASTA record names must be unique among all organisms used as mapping reference.</p>
<p>In this example, the organism <code>volpertinger</code> provides the endogenous reads as all reads were mapped only to the <code>volpertinger</code> genome. The <code>retli</code> reads are therefore exogenous reads.</p>
<p>To assign the correct organism names to the reads, the script must be provided with</p>
<ul class="incremental">
<li>The organism names</li>
<li>The FASTA index of the organism's genomes</li>
<li>The read names derived from the organism</li>
<li>Whether the reads are endogenous or exogenous</li>
<li>The table with the mapping information from the previous section which shall be augmented</li>
</ul>
<p>The call is shown below. The script <code>write_later</code> at the end of the pipe is to prevent <code>merge</code> from overwriting its own input file too soon, as the output is meant to replace the input file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/add_mapped_organisms</span> \
    --endogenous volpertinger \
                 data/genome/volpertinger.fasta.fai \
                 data/2/volpertinger.coord \
    --exogenous  retli \
                 data/retli/retli.fasta.fai \
                 data/2/retli.coord \
    data/5/1.tab \
    <span class="kw">|</span> <span class="kw">scripts/write_later</span> data/5/1.tab

<span class="kw">head</span> data/5/1.tab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>qname           rname  pos   mapq  true_organism  mapped_organism
volpertinger_0  *      0     0     volpertinger   *
volpertinger_1  MT     3402  37    volpertinger   volpertinger
volpertinger_2  A3     1413  37    volpertinger   volpertinger
volpertinger_3  A3     5689  25    volpertinger   volpertinger
volpertinger_4  *      0     0     volpertinger   *
volpertinger_5  *      0     0     volpertinger   *
volpertinger_6  A1     1320  37    volpertinger   volpertinger
volpertinger_7  A3     4480  25    volpertinger   volpertinger
volpertinger_8  X      2381  37    volpertinger   volpertinger</code></pre>
<p>To determine whether the reads were mapped correctly, two more pieces of information are needed besides the true organism: The true FASTA record (=chromosome) and the true position. These can be looked up in the files generated during the read sampling process. In this example, they were named <code>volpertinger.coord' and</code>retli.coord`. Because information for reads from both origins must be looked up, these two files must first be concatenated, but while printing the header line only once:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/cat_tables</span>   data/2/volpertinger.coord \
                     data/2/retli.coord \
                   <span class="kw">&gt;</span> data/5/all.coord
<span class="kw">head</span> data/5/all.coord <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>name            record  start  end
volpertinger_0  B1      2143   2168
volpertinger_1  MT      3402   3421
volpertinger_2  A3      1413   1436
volpertinger_3  A3      5689   5709
volpertinger_4  MT      3280   3302
volpertinger_5  A3      4936   4960
volpertinger_6  A1      1320   1340
volpertinger_7  A3      4480   4504
volpertinger_8  X       2381   2400</code></pre>
<p>As can be seen in the output above, the needed information is in the columns named <code>record</code> and <code>start</code>. The correct values are found by comparing the <code>qname</code> column of <code>data/5/1.tab</code> with the <code>name</code> column of the freshly-generated <code>data/5/all.tab</code>. Additionally we want to rename the columns holding the true chromosome and position information to make it clear which column holds which information.</p>
<p>This can be done in one go using the <code>merge</code> tool, whose invokation is written below. The used parameters are explained in the following.</p>
<p>We want to make sure no reads get lost by setting the <code>--all-a</code> option. If a read name cannot be found in <code>all.coord</code>, the tool will print <code>NA</code> at the respective position (this should not happen here). <code>--all-a-cols</code> indicates that we want to work on with all columns of <code>1.tab</code>. The input file <code>1.tab</code> is also the output file here, therefore the tool <code>write_later</code> is used.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/merge</span> -a data/5/1.tab qname \
              -b data/5/all.coord name record=true_record start=true_pos \
              --all-a-cols \
              --all-a \
              <span class="kw">|</span> <span class="kw">scripts/write_later</span> data/5/1.tab

<span class="kw">head</span> data/5/1.tab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>qname     rname  pos   mapq  true_organism  mapped_organism  true_record  true_pos
retli_0   *      0     0     retli          *                retli_tr     121502
retli_1   *      0     0     retli          *                retli_tr     133167
retli_10  *      0     0     retli          *                retli_tr     110631
retli_11  *      0     0     retli          *                retli_tr     82809
retli_12  *      0     0     retli          *                retli_tr     66530
retli_13  *      0     0     retli          *                retli_tr     108831
retli_14  *      0     0     retli          *                retli_tr     109927
retli_15  *      0     0     retli          *                retli_tr     82777
retli_16  MT     2791  25    retli          volpertinger     retli_tr     66982</code></pre>
<p>Now all the information is present to determine whether a read has been mapped correctly. The last step is writing in a new column whether a read was mapped correctly. This can be archieved using any means you can imagine, for this example we will use R. The <code>pocketR</code> tool is a thin wrapper which handles reading and writing of data for us. The input data will be available as a <code>data.frame</code> called <code>input</code>, everything written insides the parentheses of the <code>return(.)</code> statement will be printed.</p>
<p>The following command adds a new column to the input data which indicates whether a read was mapped correctly:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/pocketR</span> <span class="st">&#39;</span>
<span class="st">    within(input, {</span>
<span class="st">        correct =</span>
<span class="st">            pos == true_pos  &amp;</span>
<span class="st">            rname == true_record &amp;</span>
<span class="st">            mapped_organism == true_organism })</span>
<span class="st">&#39;</span>  data/5/1.tab \
<span class="kw">|</span> <span class="kw">scripts/write_later</span> data/5/1.tab

 <span class="kw">head</span> data/5/1.tab <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>qname     rname  pos   mapq  true_organism  mapped_organism  true_record  true_pos  correct
retli_0   *      0     0     retli          *                retli_tr     121502    FALSE
retli_1   *      0     0     retli          *                retli_tr     133167    FALSE
retli_10  *      0     0     retli          *                retli_tr     110631    FALSE
retli_11  *      0     0     retli          *                retli_tr     82809     FALSE
retli_12  *      0     0     retli          *                retli_tr     66530     FALSE
retli_13  *      0     0     retli          *                retli_tr     108831    FALSE
retli_14  *      0     0     retli          *                retli_tr     109927    FALSE
retli_15  *      0     0     retli          *                retli_tr     82777     FALSE
retli_16  MT     2791  25    retli          volpertinger     retli_tr     66982     FALSE</code></pre>
<h2 id="grouping-of-reads">Grouping of reads</h2>
<p>As next step, the number of reads are counted which belong to certain categories. Here, the categories are: * Correctly mapped or not * Origin organism * Organism a read was mapped to</p>
<p>Again, the R language can be used to express our wishes concisely: Group the reads by all combinations of:</p>
<ul class="incremental">
<li><code>true_organism</code></li>
<li><code>mapped_organism</code></li>
<li>correctly mapped</li>
</ul>
<p>... and count the reads belonging to each category:</p>
<p>the <code>cbind</code> function is needed in order to rename the column containing the read count. <code>qname</code> can be substituted here by any valid input column name, as its only used for counting (each column is equal in length).</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/pocketR</span> <span class="st">&#39;</span>
<span class="st">    aggregate( cbind(count=qname) ~ true_organism + mapped_organism + correct,</span>
<span class="st">        FUN=length, data=input)</span>
<span class="st">&#39;</span> data/5/1.tab \
<span class="kw">&gt;</span> data/5/1.agg

<span class="kw">cat</span> data/5/1.agg <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>true_organism  mapped_organism  correct  count
retli          *                FALSE    24
volpertinger   *                FALSE    8
retli          volpertinger     FALSE    1
volpertinger   volpertinger     TRUE     17</code></pre>
<p>This format may be used to plot the read fate of a single mapper run and to derive the measures sensitivity and specificity:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/plot_read_fate</span>    true_organism mapped_organism \
                          correct       count \
                          data/5/1.pdf  data/5/1.agg</code></pre></div>
<pre class="output"><code></code></pre>
<p><a href="data/5/1.pdf">Click here</a> to see the plot.</p>
<h2 id="sensitivity-and-specificity">Sensitivity and specificity</h2>
<ul class="incremental">
<li><strong>Sensitivity</strong> (recall) shows how many reads have been mapped correctly by the mapper which are supposed to map.</li>
<li><strong>Specificity</strong> (precision) shows how many reads have been correctly identified as non-endogenous and were therefore not mapped.</li>
<li><strong>Balanced control rate</strong>* (BCR) is the mean of sensitivity and specificity</li>
</ul>
<p>If non-endogenous reads were included in the reads, like we did by including the <em>R. etli</em> reads, both measures can be calculated.</p>
<p>The following script needs the same kind of input as the <code>plot-read-fate</code> script. Additionally, a list of organisms must be specified, whose genomes the mapper used as a reference.</p>
<p>If you specify multiple organisms, separate them by commas and don't include any spaces.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/sensspec</span> --c-morg mapped_organism \
                 --c-torg true_organism \
                 data/5/1.agg volpertinger \
    <span class="kw">&gt;</span> data/5/1.parameters

<span class="kw">column</span> -t data/5/1.parameters</code></pre></div>
<pre class="output"><code>map.true  map.actl  sensitivity  nomap.true  nomap.actl  specificity  bcr
25        17        0.68         25          24          0.96         0.82</code></pre>
<h2 id="repeat-all-steps-for-every-sam-file">Repeat all steps for every SAM file</h2>
<p>The code needed to evaluate the data generated by the mapper might as well be included in the mapping template script introduced in the last section. If this is done, the data evaluation can be as well parallelized as the mapping process.</p>
<p>All scripts used here were already introduced in this section.</p>
<p>The files <code>data/5/all.tab</code> and <code>data/5/all.recids</code> must be calculated prior to execution of this script. This has been done in this section as well.</p>
<p>Browse the <a href="data/5">directory <code>data/5</code></a> to see the results.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">for</span> <span class="kw">sam</span> in data/4/*.sam<span class="kw">;</span> <span class="kw">do</span>
    <span class="co"># Generate output prefix p from input name: `4.sam` -&gt; `4`</span>
    <span class="ot">bn=$(</span><span class="kw">basename</span> <span class="ot">$sam)</span>
    <span class="ot">p=${bn%</span>.sam<span class="ot">}</span>

    <span class="co"># Extract SAM fields</span>
    <span class="kw">scripts/sam_extract</span> --sam-fields qname,rname,pos,mapq \
        data/4/<span class="ot">${p}</span>.sam  <span class="kw">&gt;</span>  data/5/<span class="ot">${p}</span>.tab

    <span class="co"># Mark correctly/incorrectly mapped reads</span>
    <span class="kw">scripts/add_mapped_organisms</span> \
        --endogenous volpertinger \
                     data/genome/volpertinger.fasta.fai \
                     data/2/volpertinger.coord \
        --exogenous  retli \
                     data/retli/retli.fasta.fai \
                     data/2/retli.coord \
        data/5/<span class="ot">${p}</span>.tab \
        <span class="kw">|</span> <span class="kw">scripts/write_later</span> data/5/<span class="ot">${p}</span>.tab

    <span class="co"># Determine true origin information for each read</span>
    <span class="kw">scripts/merge</span> -a data/5/<span class="ot">${p}</span>.tab qname \
                  -b data/5/all.coord name record=true_record start=true_pos \
                  --all-a-cols \
                  --all-a \
                  <span class="kw">|</span> <span class="kw">scripts/write_later</span> data/5/<span class="ot">${p}</span>.tab

    <span class="co"># Determine whether each read was correctly mapped</span>
    <span class="kw">scripts/pocketR</span> <span class="st">&#39;</span>
<span class="st">        within(input, {</span>
<span class="st">            correct =</span>
<span class="st">                pos == true_pos  &amp;</span>
<span class="st">                rname == true_record &amp;</span>
<span class="st">                mapped_organism == true_organism })</span>
<span class="st">    &#39;</span>  data/5/<span class="ot">${p}</span>.tab \
    <span class="kw">|</span> <span class="kw">scripts/write_later</span> data/5/<span class="ot">${p}</span>.tab

    <span class="co"># Count reads per origin/target organism and mapping status</span>
    <span class="kw">scripts/pocketR</span> <span class="st">&#39;</span>
<span class="st">        aggregate( cbind(count=qname) ~ true_organism + mapped_organism + correct,</span>
<span class="st">            FUN=length, data=input) &#39;</span> \
    data/5/<span class="ot">${p}</span>.tab \
    <span class="kw">&gt;</span> data/5/<span class="ot">${p}</span>.agg

    <span class="co"># Plot mapping targets per origin organism</span>
    <span class="kw">scripts/plot_read_fate</span>    true_organism    mapped_organism \
                              correct          count \
                              data/5/<span class="ot">${p}</span>.pdf  data/5/<span class="ot">${p}</span>.agg

    <span class="co"># Calculate sensitivity, specificity and balanced accuracy</span>
    <span class="kw">scripts/sensspec</span> --c-morg mapped_organism \
                     --c-torg true_organism \
                     data/5/<span class="ot">${p}</span>.agg volpertinger \
        <span class="kw">&gt;</span> data/5/<span class="ot">${p}</span>.performance

    <span class="kw">echo</span> <span class="st">&quot;</span><span class="ot">$sam</span><span class="st"> done. -&gt; Generated data/5/</span><span class="ot">${p}</span><span class="st">.{tab,agg,pdf,performance}&quot;</span>

<span class="kw">done</span></code></pre></div>
<pre class="output"><code>data/4/0.sam done. -&gt; Generated data/5/0.{tab,agg,pdf,performance}
data/4/1.sam done. -&gt; Generated data/5/1.{tab,agg,pdf,performance}
data/4/2.sam done. -&gt; Generated data/5/2.{tab,agg,pdf,performance}
data/4/3.sam done. -&gt; Generated data/5/3.{tab,agg,pdf,performance}
data/4/4.sam done. -&gt; Generated data/5/4.{tab,agg,pdf,performance}
data/4/5.sam done. -&gt; Generated data/5/5.{tab,agg,pdf,performance}</code></pre>
<h1 id="comparing-multiple-mapper-runs">Comparing multiple mapper runs</h1>
<p>The file <code>data/4/partab</code> holds the information which parameters were used for which mapping run. By relating the output measures like sensitivity, specificity or balanced accuracy to these parameters, the influence of individual parameters can be assessed.</p>
<p>First step is to combine the output measures of all runs:</p>
<p>To this effect, to each of the <code>.performance</code>-files (contain sensitivity, specificity, bcr) generated in the last section, the run number is added as a separate column, then the <code>.performance</code>-files of all runs are concatenated to one table. Because the run number was added before, the origin of all values is still clear.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Add the run number to each .performance file</span>
<span class="kw">for</span> <span class="kw">f</span> in data/5/*.performance<span class="kw">;</span> <span class="kw">do</span>
    <span class="ot">i=$(</span><span class="kw">basename</span> <span class="ot">${f%</span>.performance<span class="ot">})</span>

    <span class="kw">scripts/add_const_column</span> <span class="st">&quot;</span><span class="ot">$f</span><span class="st">&quot;</span> runidx <span class="st">&quot;</span><span class="ot">$i</span><span class="st">&quot;</span> \
        <span class="kw">&gt;</span> <span class="st">&quot;data/6/</span><span class="ot">${i}</span><span class="st">.performance&quot;</span>
<span class="kw">done</span>

<span class="co"># Concatenate all tables, but print the header line only once.</span>
<span class="kw">scripts/cat_tables</span> data/6/*.performance \
                 <span class="kw">&gt;</span> data/6/performance

<span class="kw">cat</span> data/6/performance <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>map.true  map.actl  sensitivity  nomap.true  nomap.actl  specificity  bcr   runidx
25        1         0.04         25          25          1            0.52  0
25        17        0.68         25          24          0.96         0.82  1
25        24        0.96         25          6           0.24         0.6   2
25        1         0.04         25          25          1            0.52  3
25        17        0.68         25          24          0.96         0.82  4
25        25        1            25          6           0.24         0.62  5</code></pre>
<p>Next, the parameter values belonging to the run indices are joined in, appending the parameter columns to <code>data/6/parameters</code> itself.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">scripts/merge</span> -a data/6/performance runidx \
              -b data/4/partab      runidx \
              --all-a-cols --all-b-cols --all-a \
           <span class="kw">|</span> <span class="kw">scripts/write_later</span> data/6/performance

<span class="kw">head</span> data/6/performance <span class="kw">|</span> <span class="kw">column</span> -t</code></pre></div>
<pre class="output"><code>runidx  map.true  map.actl  sensitivity  nomap.true  nomap.actl  specificity  bcr   k   n
0       25        1         0.04         25          25          1            0.52  2   0
1       25        17        0.68         25          24          0.96         0.82  2   4
2       25        24        0.96         25          6           0.24         0.6   2   8
3       25        1         0.04         25          25          1            0.52  10  0
4       25        17        0.68         25          24          0.96         0.82  10  4
5       25        25        1            25          6           0.24         0.62  10  8</code></pre>
<p>The value of one parameter can be plotted against some measure. The following command shows plots where the X and Y axis are free to choose. If multiple runs yield a similar score on the Y axis, their data points are merged to form one bigger dot on the plot. Here all numbers are rounded to one significant digit, because only 8 mapping runs are compared in this example. Therefore results must be aggregated coarsely to demonstrate the results.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Plot n versus BCR</span>
<span class="kw">scripts/plot_parameter_effects</span> --signif 1 data/6/performance n bcr \
    data/6/n.pdf

<span class="co"># Plot k versus BCR</span>
<span class="kw">scripts/plot_parameter_effects</span> --signif 1 data/6/performance k bcr \
    data/6/k.pdf</code></pre></div>
<pre class="output"><code></code></pre>
<p>View the plots: <a href="data/6/n.pdf">n vs. BCR</a> and <a href="data/6/k.pdf">k vs. BCR</a>.</p>
<p>It can be seen that n seems to have an impact on the BCR whereas k does not. The BCR rises and falls again because the gain in sensitivity is offset by the loss in specificity if n rises too high.</p>
<h1 id="overview-of-the-scripts-by-category">Overview of the scripts by category</h1>
<p>Below you find a list of the scripts in this package, grouped by rough application situations.</p>
<p>More specific help for each command can be obtained by invoking the respective command with the <code>--help</code> or <code>-h</code> command line argument.</p>
<h2 id="general-file-and-table-manipulation">General file and table manipulation</h2>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>add_const_column</td>
<td>Add a column with a column name and fixed value.</td>
</tr>
<tr class="even">
<td>cat_tables</td>
<td>Concatenate tables with the same headers.</td>
</tr>
<tr class="odd">
<td>cross_tab</td>
<td>Print all combinations of input table rows.</td>
</tr>
<tr class="even">
<td>fill_template</td>
<td>Output copies of a file, where placeholders are replaced by values read from a table.</td>
</tr>
<tr class="odd">
<td>index_column</td>
<td>Add a column with a name and a counting number to the table.</td>
</tr>
<tr class="even">
<td>merge</td>
<td>Based on values of table 1, look up corresponding rows of table 2 (table join).</td>
</tr>
<tr class="odd">
<td>pocketR</td>
<td>Change text tables by R commands.</td>
</tr>
<tr class="even">
<td>write_later</td>
<td>Cache the input and write it only after input completion, to enable file modification without (explicit) temporary files.</td>
</tr>
</tbody>
</table>
<h2 id="read-sampling-and-fitering">Read sampling and fitering</h2>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>filter_fastq</td>
<td>Apply a program to ID, nucleotide or quality string of each read.</td>
</tr>
<tr class="even">
<td>uniform</td>
<td>Sample reads from a reference genome.</td>
</tr>
<tr class="odd">
<td>synth_fastq</td>
<td>Create a FASTQ file from input IDs, nucleotide strings and quality strings.</td>
</tr>
</tbody>
</table>
<h2 id="introducing-mutations-into-reads">Introducing mutations into reads</h2>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>geom_induce</td>
<td>Change bases of input nucleotide strings with a probability dependent of proximity to the string beginning or end.</td>
</tr>
<tr class="even">
<td>mapdamage2geomparam</td>
<td>Parse output of mapDamage an output a table of base mutation probabilities.</td>
</tr>
<tr class="odd">
<td>multiple_mutate</td>
<td>Based on a table of base mutation probabilities, apply multiple mutation rounds to nucleotide strings.</td>
</tr>
<tr class="even">
<td>plot_mutation_probabi</td>
<td>lities Plot mutation probability versus base position.</td>
</tr>
</tbody>
</table>
<h2 id="parallel-program-calls-e.g.-mappers">Parallel program calls (e.g. mappers)</h2>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mcall</td>
<td>Read a list of program calls and invoke several of them in parallel.</td>
</tr>
<tr class="even">
<td>table2calls</td>
<td>Based on a table of parameters, generate calls to a script with changing parameters.</td>
</tr>
</tbody>
</table>
<h2 id="sam-parsing-and-result-data-handling">SAM parsing and result data handling</h2>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>add_mapped_organisms</td>
<td>Add organisms relating to FASTA record names in the input tables to the output.</td>
</tr>
<tr class="even">
<td>plot_read_fate</td>
<td>Plot how many reads from which origin were mapped to which target organism correctly or incorrectly.</td>
</tr>
<tr class="odd">
<td>plot_parameter_effects</td>
<td>Plot how much mapping parameters influence sensitivity or specificity</td>
</tr>
<tr class="even">
<td>sam_extract</td>
<td>Extract information from a SAM file into a text table.</td>
</tr>
<tr class="odd">
<td>sensspec</td>
<td>Calculate sensitivity and specificity of a mapping run.</td>
</tr>
</tbody>
</table>
<h1 id="glossary">Glossary</h1>
<p>Some terms are explained here, which are used in the rest of the manual and may have a special meaning:</p>
<p>~table: A text table is the most widely used data format in this project. It is a simple text file, where the columns are separated by a special character. Usually this is a tabulator (tab) character, but sometimes space-separated tables are also used.</p>
<p>~FASTA record: A FASTA record is a block in a fasta file which is delimited by two &gt; signs. It consists of the following parts:</p>
<ol class="incremental" style="list-style-type: decimal">
<li>The header line: &gt;.................(line end).
<ol class="incremental" style="list-style-type: lower-alpha">
<li>The FASTA identifier, which is the first 'word' of the header line. E.g. in a header line</li>
</ol>
<blockquote>
<p>A1 Felis catus genome ID:012345...</p>
</blockquote>
<pre><code>the FASTA identifier is &#39;A1&#39;.</code></pre>
<ol class="incremental" start="2" style="list-style-type: lower-alpha">
<li>The FASTA record description: All the text between identifier and line end.</li>
</ol></li>
<li>Biological sequence data, IUPAC one-character-code. Should not be wider than 80 characters and may contain whitespace. E.g. nucleotides: ACCTCTCTACCT...</li>
</ol>
<p>~FASTA identifier: -&gt; FASTA record</p>
<p>~FASTA description: -&gt; FASTA record</p>
<p>~file offset: This is the distance in bytes from the beginning of a file. The first character of a file has the offset 0.</p>
<p>~offset: -&gt; file offset</p>
<p>~i-based index: An index is i-based if it starts counting with number i. For example, the mapping position (pos) field of a SAM file is a 1-based index. If the position 1 is written there, the read maps to the first base of the genome. Conversely, if the index were 0-based, the first base of the genome would be referenced with the number 0.</p>
<p>~0-based: -&gt; i-based index</p>
<p>~1-based: -&gt; i-based index</p>
<p>~standard input: Many commands expect input on this stream. Input can be provided either by typing into the console, by using the &lt; operator to provide input from a file or by the | operator, which forwards the content on standard output of a previous command to standard input of this command. Refer to the &quot;Redirection&quot; section of your shell for more information.</p>
<p>~standard output: All output a command writes is by default redirected to the standard output or standard error streams. Per convention, standard output is used for the results of the program, whereas standard error is used for status and error messages. Content on standard output can be written in a file by using the &gt; operator or redirected to standard input of another command by using the | operator. Standard error output can be redirected to a file using the 2&gt; operator. Consult the &quot;Redirection&quot; section of your shell for more information.</p>
<p>~standard error: -&gt; standard output</p>
<p>~command line argument: a value which is written on the command line behind the name of the program which shall be invoked. They are forwarded to the program and influence it. The valid parameters of a program are described in the program's manual. (often accessible via the <code>--help</code> command line argument.</p>
<p>~command line switch: -&gt; command line argument</p>
</body>
</html>
