Generate mapper calls
=====================

To generate the calls to the mapper using different combinations of 
parameters, several files holding the values of the different parameters
are first combined to a table holding all possible combinations of them.

Subsequently, every line is given a unique index which can be referred to
e.g. when writing output files of the mapping process. By this index, each
run writes to a different output file.

The parameter values are saved in several files, one per parameter. 
In this example, the BWA parameters n and k are varied which results
in two files:

```{.sh}
ls data/mapping/*.par
```

The files can have arbitrary filenames, they are in a tabular format
where the column names relate to variables which are set automatically
later in the process.

```{.sh}
column -t data/mapping/n.par
```

To generate all combinations of parameters, two scripts are used:

  * `scripts/cross_tab` expects multiple files and outputs all
    possible combinations of their lines. 

  * `scripts/index-column` This script prepends a counting number 
    to each input line. It can be used to generate index columns for text 
    tables.

Generate all possible combinations of parameters, retaining 1 header
line:

```{.sh}
scripts/cross_tab --head 1 data/mapping/*.par > data/4/partab
head data/4/partab | column -t
```

Add an index column called runidx:
```{.sh}
scripts/index-column --colname runidx --inplace data/4/partab
head data/4/partab | column -t
```

Read now the script `data/mapping/map-bwa.sh` and see how the variables
used there correspond to the column names of partab. The script is
shown in the next code block. 

This is a script which can be called using different parameter
combinations: It calls the mapper `bwa` and forwards the values of the
variables set via `data/4/partab` as command line arguments to the
mapper. 

```{.bash}
#!/usr/bin/bash

## This script performs a mapping using BWA.
## It requires the variables k, n, runidx and fastq be set 
## prior to its execution.

# Fail if any needed variable is not set
set -ue

bwa aln -n ${n} -k ${k}      \
    data/genome/volpertinger \
    data/3/all.fastq         \
    > data/4/${runidx}.sai   \
    2> data/4/${runidx}.log   &&

bwa samse                      \
      data/genome/volpertinger \
      data/4/${runidx}.sai     \
      data/3/all.fastq         \
      > data/4/${runidx}.sam   \
      2>> data/4/${runidx}.log

```

Below the calls are generated.

```{.sh}
# Convert the table into calls that can be executed in the next section
scripts/table2calls  data/4/partab \
                    data/mapping/map-bwa.sh \
                  > data/4/calls
cat data/4/calls
```

Executing multiple mapping runs in parallel
===========================================

For this task, many programs can be used, from simple shell background
spawning using & (in bash) to job managers orchestrating a big network
of worker machines. In this package, a simple program is implemented
which executes a user-definable number of jobs in parallel and
waits with spawning new ones until another of its already started jobs
finishes.

Note that some mappers can use more than one processor core
themselves. Therefore if you spawn multiple mapper processes where
each mapper process utilizes multiple cores, the total number of
utilized cores is the number of cores used per mapper multiplied with
the number of mapper processes launched in parallel.

Invoke `scripts/mcall --help` to get more information about
this tool.

Example: Run the previously generated mapper calls. 

```{.sh}
    # Execute calls, at 2 cores
    scripts/mcall -c data/4/calls -t 2 \
                  --status
    # Standard error was piped to log files, 
    # Standard output was piped to sam files, as specified in the
    # `tmpl` file.
    head data/4/0.log
    head -n15 data/4/0.sam
```



vim:tw=70
