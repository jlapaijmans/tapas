Parsing of SAM files
====================

With the following tools, SAM files can be parsed to gain information of read
names, where they were mapped, which quality score the mapping was assigned
and so on. 

The procedures in this chapter may vary more than the previous ones, 
depending on the research question.

In the setting this package was originally designed for, the names of the
reads carry the information where the reads actually belong to. This
information can subsequently be compared to the actual mapping information
obtained from the SAM file.

Extraction of information
-------------------------

For this purpose, the `sam-extract.R` tool can be used. This tool
converts a SAM file into a table, where the columns can be
informations obtained from the read names or SAM fields. The names of
the SAM fields can be looked up in the SAM specification online, but
the most important ones are:

* qname: read name
* rname: FASTA record name of genome this read was mapped to. `*` if 
         not mapped.
* pos:   base index of mapping position (1-based index!)
* mapq:  quality score assigned by the mapper
* cigar: CIGAR String: Information about gaps and mismatches in
         the alignment read -- reference

Take care not to put any spaces in the argument of --sam-fields.

```{.sh}
scripts/sam_extract --sam-fields qname,rname,pos,mapq \
    data/4/1.sam  >  data/5/1.tab
```

```{.sh}
head data/5/1.tab | column -t
```

```{.sh}
tail data/5/1.tab | column -t
```

Gather all information needed to determine correct mapping
----------------------------------------------------------

The script `add_mapped_organisms` adds two columns to the result
above: The column `true_organism` lists the organism a read stems
from. This is an important information if the FASTA record names of
several species used in the analysis overlap. This is sometimes the
case when multiple eukaryotes are used. The second column,
`mapped_organism`, infers the organism a read has been assigned to by
the mapper. This is done by looking up the FASTA record name, which
the read was mapped to, in all FASTA record names of all species which
where used as reference genomes by the mapper. This FASTA record names
must be unique among all organisms used as mapping reference.

In this example, the organism `volpertinger` provides the endogenous
reads as all reads were mapped only to the `volpertinger` genome. The
`retli` reads are therefore exogenous reads.

To assign the correct organism names to the reads, the script must be provided
with

 * The organism names
 * The FASTA index of the organism's genomes
 * The read names derived from the organism
 * Whether the reads are endogenous or exogenous
 * The table with the mapping information from the previous section
   which shall be augmented

The call is shown below. The script `write_later` at the end of the
pipe is to prevent `merge` from overwriting its own input file too
soon, as the output is meant to replace the input file.

```{.sh}
scripts/add_mapped_organisms \
    --endogenous volpertinger \
                 data/genome/volpertinger.fasta.fai \
                 data/2/volpertinger.coord \
    --exogenous  retli \
                 data/retli/retli.fasta.fai \
                 data/2/retli.coord \
    data/5/1.tab \
    | scripts/write_later data/5/1.tab

head data/5/1.tab | column -t
```

To determine whether the reads were mapped correctly, two more pieces
of information are needed besides the true organism: The true FASTA
record (=chromosome) and the true position. These can be looked up in
the files generated during the read sampling process. In this example,
they were named `volpertinger.coord' and `retli.coord`. Because
information for reads from both origins must be looked up, these two
files must first be concatenated, but while printing the header line
only once:

```{.sh}
scripts/cat_tables   data/2/volpertinger.coord \
                     data/2/retli.coord \
                   > data/5/all.coord
head data/5/all.coord | column -t
```

As can be seen in the output above, the needed information is in the
columns named `record` and `start`. The correct values are found by
comparing the `qname` column of `data/5/1.tab` with the `name` 
column of the freshly-generated `data/5/all.tab`. Additionally we
want to rename the columns holding the true chromosome and position
information to make it clear which column holds which information.

This can be done in one go using the `merge` tool, whose invokation is
written below. The used parameters are explained in the following.

We want to make sure no reads get lost by setting the
`--all-a` option. If a read name cannot be found in `all.coord`, the
tool will print `NA` at the respective position (this should not
happen here). `--all-a-cols` indicates that we want to work on with
all columns of `1.tab`. The input file `1.tab` is also the output file
here, therefore the tool `write_later` is used.

```{.sh}
scripts/merge -a data/5/1.tab qname \
              -b data/5/all.coord name record=true_record start=true_pos \
              --all-a-cols \
              --all-a \
              | scripts/write_later data/5/1.tab

head data/5/1.tab | column -t
```

Now all the information is present to determine whether a read has
been mapped correctly. The last step is writing in a new column
whether a read was mapped correctly. This can be archieved using any
means you can imagine, for this example we will use R. The `pocketR`
tool is a thin wrapper which handles reading and writing of data for
us. The input data will be available as a `data.frame` called
`input`, everything written insides the parentheses of the `return(.)`
statement will be printed. 

The following command adds a new column to the input data which
indicates whether a read was mapped correctly:

```{.sh}
scripts/pocketR '
    within(input, { 
        correct =    
            pos == true_pos  &
            rname == true_record &
            mapped_organism == true_organism })
'  data/5/1.tab \
| scripts/write_later data/5/1.tab

 head data/5/1.tab | column -t
```
 


Grouping of reads
-----------------

As next step, the number of reads are counted which belong to 
certain categories. Here, the categories are:
  * Correctly mapped or not
  * Origin organism
  * Organism a read was mapped to

Again, the R language can be used to express our wishes concisely:
Group the reads by all combinations of:

 * `true_organism`
 * `mapped_organism`
 * correctly mapped

... and count the reads belonging to each category:

the `cbind` function is needed in order to rename the column containing 
the read count. `qname` can be substituted here by any valid input
column name, as its only used for counting (each column is equal in
length). 

```{.sh}
scripts/pocketR '
    aggregate( cbind(count=qname) ~ true_organism + mapped_organism + correct,
        FUN=length, data=input)
' data/5/1.tab \
> data/5/1.agg

cat data/5/1.agg | column -t
```

This format may be used to plot the read fate of a single mapper run
and to derive the measures sensitivity and specificity:

```{.sh}
scripts/plot_read_fate    true_organism mapped_organism \
                          correct       count \
                          data/5/1.pdf  data/5/1.agg
```

<a href="data/5/1.pdf">Click here</a> to see the plot.

Sensitivity and specificity
---------------------------

  * **Sensitivity** (recall) shows how many reads have been mapped
    correctly by the mapper which are supposed to map.
  * **Specificity** (precision) shows how many reads have been
    correctly identified as non-endogenous and were therefore not
    mapped.
  * **Balanced control rate*** (BCR) is the mean of sensitivity and
    specificity

If non-endogenous reads were included in the reads, like we did by
including the *R. etli* reads, both measures can be calculated.

The following script needs the same kind of input as the
`plot-read-fate` script. Additionally, a list of organisms must be
specified, whose genomes the mapper used as a reference. 

If you specify multiple organisms, separate them by commas and don't
include any spaces.

```{.sh}
scripts/sensspec --c-morg mapped_organism \
                 --c-torg true_organism \
                 data/5/1.agg volpertinger \
    > data/5/1.parameters

column -t data/5/1.parameters
```



Repeat all steps for every SAM file
-----------------------------------

The code needed to evaluate the data generated by the mapper might as
well be included in the mapping template script introduced in the last
section. If this is done, the data evaluation can be as well
parallelized as the mapping process.

All scripts used here were already introduced in this section.

The files `data/5/all.tab` and `data/5/all.recids` must be calculated
prior to execution of this script. This has been done in this section 
as well.

Browse the <a href="data/5">directory `data/5`</a> to see the results.

```{.sh}
for sam in data/4/*.sam; do
    # Generate output prefix p from input name: `4.sam` -> `4`
    bn=$(basename $sam)
    p=${bn%.sam}

    # Extract SAM fields
    scripts/sam_extract --sam-fields qname,rname,pos,mapq \
        data/4/${p}.sam  >  data/5/${p}.tab

    # Mark correctly/incorrectly mapped reads
    scripts/add_mapped_organisms \
        --endogenous volpertinger \
                     data/genome/volpertinger.fasta.fai \
                     data/2/volpertinger.coord \
        --exogenous  retli \
                     data/retli/retli.fasta.fai \
                     data/2/retli.coord \
        data/5/${p}.tab \
        | scripts/write_later data/5/${p}.tab

    # Determine true origin information for each read
    scripts/merge -a data/5/${p}.tab qname \
                  -b data/5/all.coord name record=true_record start=true_pos \
                  --all-a-cols \
                  --all-a \
                  | scripts/write_later data/5/${p}.tab

    # Determine whether each read was correctly mapped
    scripts/pocketR '
        within(input, { 
            correct =    
                pos == true_pos  &
                rname == true_record &
                mapped_organism == true_organism })
    '  data/5/${p}.tab \
    | scripts/write_later data/5/${p}.tab

    # Count reads per origin/target organism and mapping status
    scripts/pocketR '
        aggregate( cbind(count=qname) ~ true_organism + mapped_organism + correct,
            FUN=length, data=input) ' \
    data/5/${p}.tab \
    > data/5/${p}.agg

    # Plot mapping targets per origin organism 
    scripts/plot_read_fate    true_organism    mapped_organism \
                              correct          count \
                              data/5/${p}.pdf  data/5/${p}.agg

    # Calculate sensitivity, specificity and balanced accuracy
    scripts/sensspec --c-morg mapped_organism \
                     --c-torg true_organism \
                     data/5/${p}.agg volpertinger \
        > data/5/${p}.performance

    echo "$sam done. -> Generated data/5/${p}.{tab,agg,pdf,performance}"

done
```

    

vim:tw=70
