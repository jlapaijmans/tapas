# Don't overwrite files if this should be executed as a script
set -ueC

cd $pr/data/gen/cat_mappings/bwa/1

# Used scripts
s_sam_extract="$pr/scripts/eval/sam-extract.R"
s_pocketr="$pr/scripts/general/pocketR.R"
s_sensspec="$pr/pipelines/map-cat-genome/sensspec.R"
s_param_model="$pr/pipelines/param-anova.R"
s_add_column="$pr/scripts/general/add_const_column.sh"

# Input directories
d_mutpar="$pr/data/gen/artif-mutpar"

#' Extract interesting fields from SAM files:
#'   qname  = read name            
#'   rname  = reference name
#'   pos    = mapping position
#'   mapq   = mapping quality score
#' Fields generated from read name:
#'   torg   = true origin genome   
#'   tchrno = true origin FASTA record number
#'   tpos   = true mapping position
#' Add a column specifying SAM file name to the output file
for f in $(ls run/*.sam.gz); do
    f=${f##*/} # Remove folder names
    i=${f%.sam.gz} # Remove file name ext

    $s_sam_extract --gz --sam-fields qname,rname,pos,mapq \
                        --pattern "{torg}_{tchrno}_{tpos}_.*" \
        run/${i}.sam.gz > run/${i}.tab

    $s_add_const_column run/${i}.tab run ${i}
done

#' There is one table for each .sam.gz file; concatenate them.
#'
# Write header line (column names) to file
head -1 run/1.tab > all.tab

# Append all *.tab files without their header lines
awk '(FNR!=1)' run/*.tab >> all.tab

#' Preview output
head all.tab


# Determine which reads where mapped correctly
R --no-save <<EOF

# Read in cat chromosomes with record index in reference FASTA
chrs <- read.table("../../../genome-info/fcatus.records.tab",header=TRUE,
row.names=NULL)

# Read mapping data of every read
t <- read.table("all.tab",colClasses="character",header=TRUE)

# Add FASTA record number for mapping targets of all reads 
t <- merge(t, chrs, by.x="rname", by.y="chr.name",all.x=TRUE)

# Chromosome number was encoded in the read name, needs to be numeric
t\$tchrno <- as.numeric(t\$tchrno)
# Get chromosome name for that number (for every read)
t\$t.chr <- chromosomes[t\$tchrno + 1]
# New column: "fcatus" if read is from a cat chromosome, * else
t\$org <- ifelse(t\$rname %in% chromosomes,"fcatus","*")

# Mapping is correct if chromosome number and base position match
t\$correct.mapping <- with(t,{
    (rname == t.chr) & tpos == pos
})

agg <- aggregate(qname ~ torg + org + correct.mapping + run, data=t,
                FUN=length)
i <- which(colnames(agg) == "qname")
colnames(agg)[i] <- "count"

write.table(agg,file="agg.tab",quote=FALSE, row.names=FALSE, sep="\t")
EOF

$s_sensspec --c-correct correct.mapping --c-torg torg --c-morg org \
            agg.tab > sensspec.tab
            
# Merge with parameter table and mutation parameters

$s_pocketr '
output <- merge(inputs[[1]], inputs[[2]], by.x="run", by.y="index")
output <- merge(output, inputs[[3]], by.x="mut",by.y="index")
return(output)
'   sensspec.tab pars.tab $d_mutpar/combination_indices \
    > sensspec.tab.tmp &&
mv sensspec.tab.tmp sensspec.tab

#less sensspec.tab

head -n1 sensspec.tab
#less agg.tab.tmp


$s_param_model sensspec.tab \
    "sensitivity~(k+l+M+n)*(geom_prob+factor+all_intercept)"


R

library(ggplot2)
library(tidyr)
library(magrittr)
library(dplyr)
library(lazyeval)

t <- read.table("sensspec.tab", row.names=NULL, header=TRUE)
times <- read.table("runtimes", row.names=NULL, 
                    col.names=c("run","exit.code","time"))
times <- times[,c(1,3)]

times <- merge(t, times, by="run", all.x=TRUE)
times

colnames(t)

t$k %<>% as.factor
t$l %<>% as.factor
t$M %<>% as.factor
t$n %<>% as.factor
t$all_intercept %<>% as.factor
t$geom_prob %<>% as.factor
t$factor %<>% as.factor
# Method 1
# ======================================================================

runPlot <- function(data, x, y, color){
    name <- paste(x,y,color,".pdf",sep="_")
    counts <- data %>% 
              mutate_(measure = 
                      interp(~signif(y, 1), y=as.name(y))) %>%
              group_by_(x, color, ~measure) %>%
              summarise_(count = 
                  interp(~length(color), color=as.name(color)))
    p <- ggplot(counts) + aes_string(x=x, y="measure", 
                                size="count", color=color) + 
                    scale_y_continuous(name=y) +
                    geom_point()
    ggsave(filename=name,plot=p, width=5,height=3, dpi=100)
}

runPlot(t, "k", "sensitivity", "all_intercept")
runPlot(t, "k", "specificity", "all_intercept")
runPlot(t, "l", "sensitivity", "all_intercept")
runPlot(t, "l", "specificity", "all_intercept")
runPlot(t, "M", "sensitivity", "all_intercept")
runPlot(t, "M", "specificity", "all_intercept")
runPlot(t, "n", "sensitivity", "all_intercept")
runPlot(t, "n", "specificity", "all_intercept")
runPlot(t, "factor", "sensitivity", "geom_prob")
runPlot(t, "geom_prob", "sensitivity", "all_intercept")

runPlot(times,"k","time","all_intercept")
runPlot(times,"l","time","all_intercept")
runPlot(times,"M","time","all_intercept")
runPlot(times,"k","time","all_intercept")
runPlot(times,"n","time","all_intercept")
runPlot(times,"n","time","all_intercept")







# Method 2
# ======================================================================

group <- function(x, breaks, log=FALSE, labels=NULL, right=TRUE, ...){
    if(log){
        stopifnot(length(breaks) >= 2)
        e.range <- x %>% log10 %>% floor %>% range 
        e.range %<>% {.[1]:.[2]} %>% matrix(nrow=1)
        breaks <- matrix(breaks, ncol=1)
        breaks <- as.numeric(breaks %*% 10^e.range)
        if(missing(right)){ right <- FALSE }
    }
    breaks <- sort(unique(breaks))
    if(missing(labels)) labels <- NULL 
    else if(!is.null(labels) && labels == "log") {
        labels <- paste0("â‰¥",breaks)[1:(length(breaks)-1)]
        labels[length(labels)] <- 
        paste0(labels[length(labels)]," <", breaks[length(breaks)])
    }
    if(missing(right)) right=TRUE
    return(cut(x, breaks, labels=labels, right=right, ...))
}

count <- t %>% mutate(sensitivity = group(sensitivity, log=TRUE,
                breaks=0:10, labels="log", ordered=T)) %>%
      group_by(all_intercept, sensitivity,l) %>%
      summarise(count = ceiling(length(n)/10))

      
# Method 3
# ====================================================================

t1 <- gather(t, key="measure", val="val", sensitivity, specificity)

t1$all_intercept %<>% as.factor
t1$geom_prob %<>% as.factor
t1$factor %<>% as.factor
t1$k %<>% as.factor
t1$l %<>% as.factor
t1$M %<>% as.factor
t1$n %<>% as.factor
str(t1)

p <- ggplot(t1) + aes(y=val,color=all_intercept, fill=all_intercept) + 
        facet_wrap(~measure) + 
        theme(#panel.grid.minor = element_blank(),
              #panel.grid.major = element_blank(),
              strip.background = element_blank()) + 
        scale_color_discrete(name="all_intercept") + 
        scale_y_log10()




p + geom_point(mapping=aes(x=all_intercept)) 
p + geom_point(mapping=aes(x=factor)) 
p + geom_point(mapping=aes(x=geom_prob)) 
p + geom_violin(mapping=aes(x=n))
p + geom_jitter(mapping=aes(x=n), alpha=0.3) 
p + geom_jitter(mapping=aes(x=M), alpha=0.3) 
p + geom_point(mapping=aes(x=M)) 
p + geom_point(mapping=aes(x=n)) 

# vim:ft=sh:tw=70

