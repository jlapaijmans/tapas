# don't delete data if this file should be executed non-interactively
set -ueC

# --------------------------------------------------------------------

# Output directory
mkdir 01_out
cd 01_out

mkdir genome_data
mkdir reads_pre
mkdir reads



# Path to scripts folder
scd="../../scripts"

# -----------------------------------------------------------------------------

# Used scripts: invoke these with the --help switch to get further 
# information (or -h if that doesn't work)
#
# Index of large genomes
s_fasta_index="$scd/generate-reads/nucl/extract-ref/fasta_record_index"
# Remove newlines and whitespace in reference genomes (easier indexing)
s_linearize_fasta="$scd/generate-reads/nucl/extract-ref/linearize_fasta"
# Print table of FASTA record identifiers
s_record_table="$scd/genome/mfasta-idlist.sh"
# Extraction of fragments out of a reference sequence
s_nucl_uniform="$scd/generate-reads/nucl/extract-ref/uniform.py"
# Generate quality scores for nucleotide strings
s_quali_const="$scd/generate-reads/quali/gen-constant-score.pl"
# Compose a FASTQ from its components ID, nucleotide and quality string
s_synth_fastq="$scd/generate-reads/synth-fastq.py"

# Input data:
#
# Reference sequences
d_ref="../../data/ref"

# -----------------------------------------------------------------------------

# Prepare the input genomes for read extraction:
#
# 1. Linearization: remove whitespace and newlines from FASTA files (except header)
# 2. Index: Save file offsets of FASTA records
# 3. Record IDs: These are needed to map the true read origins (saved in the 
#                read names) to the 'rname' (mapped to) field in resulting SAM
#                files
function prepare(){
    org=$1

    $s_linearize_fasta "$d_ref/${org}/${org}.fasta" \
        > genome_data/${org}.fasta.lin

    $s_fasta_index genome_data/${org}.fasta.lin > genome_data/${org}.idx

    # Output: Table of record index, record name, organism name (second arg)
    # Needed to determine the organism and the FASTA record number a read was
    # mapped to from the 'rname' field in the SAM file after mapping.
    # This is then compared with the info in the read ID (SAM 'qname' field).
    $s_record_table $d_ref/${org}/${org}.fasta \
        > genome_data/${org}.records
}

prepare fcatus
prepare bsubtilis
prepare scoelicolor

# 1. Extract 100 reads of length 40Â±5 (SD) 
# 2a. Generate three lists (i,n,q) with indices, nucleotides, quality.
# 2b. Add organism name to index lines
# 4. Merge IDs, Nucleotide strings and quality stings to FASTQ
# The reads' ids will hold the true organism, chromosome and mapping position
# of the reads.
function generate_reads(){
    org=$1
    # Table of read origin and nucleotide strings
    # Numeric arguments: Count, length, length_sd of reads
    $s_nucl_uniform --index      genome_data/${org}.idx       \
                    --linearized genome_data/${org}.fasta.lin \
                    100  40  5  > reads_pre/${org}.tab

    # Read ID list
    grep -v "^#" reads_pre/${org}.tab | \
    awk -v org=$org -v OFS='_' \
         '{print org,$1,$2,$3 > "reads_pre/"org".i";
           print $4           > "reads_pre/"org".n"}'

    # Read quality lines: only FFFFFFF....
    $s_quali_const F < reads_pre/${org}.n  > reads_pre/${org}.q

    # Merge all these to a FASTQ file
    $s_synth_fastq reads_pre/${org}.{n,q,i} > reads/${org}.fastq
}

generate_reads fcatus
generate_reads bsubtilis
generate_reads scoelicolor


# vim:ft=sh


